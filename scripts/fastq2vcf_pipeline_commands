#! /usr/bin/env python3

from configparser import ConfigParser
from configparser import ExtendedInterpolation
from os.path import dirname
from pathlib import Path
from subprocess import run
from time import perf_counter_ns
from typing import Optional

import shutil
import sys


###########################################################################
# --  Configuration file sections and keys
###########################################################################

# Global parameters
GLOBAL_SECTION = "Global"
CREATE_OUTPUT_DIRS = "create_output_dirs"
CLEAR_OUTPUT_DIRS = "clear_output_dirs"

# Processing steps
PROCESSING_STEPS_SECTION = "ProcessingSteps"
BWA_MEM2_INDEX_REFERENCE_FASTA = "bwa_mem2_index_reference_fasta"
FASTQC = "fastqc"
REPAIR_FASTQ = "repair_fastq"
FASTP = "fastp"
MAPPING_BWA = "mapping_bwa"
QUALIMAP_BAMQC = "qualimap_bamqc"
QUALIMAP_MULTI_BAMQC = "qualimap_multi_bamqc"

# Directory and file paths
FILE_PATHS_SECTION = "FilePaths"
REFERENCE_FASTA_FILE = "reference_fasta_file"
FASTQ_DIR = "fastq_dir"
FASTQC_DIR = "fastqc_dir"
REPAIR_DIR = "repair_dir"
FASTP_DIR = "fastp_dir"
MAPPING_BWA_DIR = "mapping_bwa_dir"
MAPPING_QC_DIR = "mapping_qc_dir"
INPUT_GROUPS_FILE = "input_groups_file"

###########################################################################
# --  Configuration parameters
###########################################################################


def read_config() -> ConfigParser:
    # The config file is either provided as the first script parameter,
    # or it is the file fastq2vcf_pipeline_commands.ini within the script
    # directory
    if len(sys.argv) > 1:
        config_path = sys.argv[1]
    else:
        script_dir = Path(dirname(Path(sys.argv[0]).resolve()))
        config_path = script_dir / "fastq2vcf_pipeline_commands.ini"

    # -- Read the config file
    config = ConfigParser(interpolation=ExtendedInterpolation())
    config.read(config_path)

    return config


CONFIG: ConfigParser = read_config()


# List of the raw FASTQ input files
# Use the get_fastq_file_names() for accessing this list.
fastq_file_names: Optional[list[str]] = None


def process_step(config_var: str) -> bool:
    return CONFIG.getboolean(PROCESSING_STEPS_SECTION, config_var, fallback=False)


def file_path(config_var: str) -> Optional[Path]:
    p = CONFIG.get(FILE_PATHS_SECTION, config_var, fallback=None)
    if p:
        p = Path(p)
    return p


def get_fastq_file_names() -> list[str]:
    # TODO check that the second file in each tuple actually exists
    #  and is a file
    global fastq_file_names
    if not fastq_file_names:
        fastq_file_names = [
            (fastq_file_name_1.name, fastq_file_name_1.name.replace("_1.fastq", "_2.fastq"))
            for fastq_file_name_1 in file_path(FASTQ_DIR).glob("*_1.fastq*")]

    return fastq_file_names


def check_and_prepare_output_dir(output_dir: Path) -> None:
    # Create the directory if it does not already exist (only if configured)
    if not output_dir.is_dir():
        if CONFIG.getboolean(GLOBAL_SECTION, CREATE_OUTPUT_DIRS, fallback=False):
            output_dir.mkdir()
        else:
            raise SystemExit(f"Error: Required directory {output_dir} does not exist.")
    # Clear the directory if not empty (only if configured)
    if CONFIG.getboolean(GLOBAL_SECTION, CLEAR_OUTPUT_DIRS, fallback=False) and any(output_dir.iterdir()):
        shutil.rmtree(output_dir)
        output_dir.mkdir()


def check_and_prepare_output_dirs() -> None:
    if process_step(FASTQC):
        check_and_prepare_output_dir(file_path(FASTQC_DIR))
    if process_step(REPAIR_FASTQ):
        check_and_prepare_output_dir(file_path(REPAIR_DIR))
    if process_step(FASTP):
        check_and_prepare_output_dir(file_path(FASTP_DIR))
    if process_step(MAPPING_BWA):
        check_and_prepare_output_dir(file_path(MAPPING_BWA_DIR))
    if process_step(QUALIMAP_BAMQC):
        check_and_prepare_output_dir(file_path(MAPPING_QC_DIR))


def bwa_mem2_index_reference_fasta() -> None:
    run(["bwa-mem2", "index", file_path(REFERENCE_FASTA_FILE)])


def fastqc(f1: str, f2: str) -> None:
    run([
        "fastqc",
        "--threads", "8",
        "-o", file_path(FASTQC_DIR),
        file_path(FASTQ_DIR) / f1,
        file_path(FASTQ_DIR) / f2])


def repair_fastq(f1: str, f2: str) -> None:
    run([
        "repair.sh",
        "overwrite=true",
        "in1=" + str(file_path(FASTQ_DIR) / f1),
        "in2=" + str(file_path(FASTQ_DIR) / f2),
        "out1=" + str(file_path(REPAIR_DIR) / f1.replace("_1.fastq", "_fixed_1.fastq")),
        "out2=" + str(file_path(REPAIR_DIR) / f2.replace("_2.fastq", "_fixed_2.fastq")),
        "outsingle=" + str(file_path(REPAIR_DIR) / f1.replace("_1.fastq", "_singletons.fastq"))])


def fastp(f1: str, f2: str) -> None:
    run([
        "fastp",
        "--thread", "8",
        "--in1", str(file_path(REPAIR_DIR) / f1.replace("_1.fastq", "_fixed_1.fastq")),
        "--in2", str(file_path(REPAIR_DIR) / f2.replace("_2.fastq", "_fixed_2.fastq")),
        "--out1", str(file_path(FASTP_DIR) / f1.replace("_1.fastq", "_trim_1.fastq")),
        "--out2", str(file_path(FASTP_DIR) / f2.replace("_2.fastq", "_trim_2.fastq")),
        "--length_required", "50",
        "--html", file_path(FASTP_DIR) / (f1.replace("_1.fastq", "_trim_1_2.fastq") + "_report.html")],
        stderr=(file_path(FASTP_DIR) / (f1.replace("_1.fastq", "_trim_1_2.fastq") + ".log")).open("w"))


def map_bwa(f1: str, f2: str) -> None:
    sam_file_path = file_path(MAPPING_BWA_DIR) / f1.replace("_1.fastq.gz", ".sam")
    bam_file_path = file_path(MAPPING_BWA_DIR) / f1.replace("_1.fastq.gz", ".bam")
    sorted_bam_file_path = file_path(MAPPING_BWA_DIR) / f1.replace("_1.fastq.gz", "_sorted.bam")
    # Map the trimmed FASTQ files to the reference FASTA file
    run([
        "bwa-mem2", "mem", "-M",
        "-t", "8",
        file_path(REFERENCE_FASTA_FILE),
        file_path(FASTP_DIR) / f1.replace("_1.fastq", "_trim_1.fastq"),
        file_path(FASTP_DIR) / f2.replace("_2.fastq", "_trim_2.fastq")],
        stdout=sam_file_path.open("w"))
    # Convert the SAM file into BAM format
    run([
        "samtools", "view", "--bam", "-S",
        "--threads", "8",
        sam_file_path],
        stdout=bam_file_path.open("w"))
    # Sort the BAM file
    run([
        "samtools", "sort",
        "--threads", "8",
        "-o", sorted_bam_file_path,
        bam_file_path])
    # Index the sorted BAM file
    run([
        "samtools", "index",
        "--threads", "8",
        sorted_bam_file_path])
    # Delete the unsorted BAM and SAM files
    sam_file_path.unlink()
    bam_file_path.unlink()


def qualimap_bamqc(f1: str) -> None:
    run([
        "qualimap", "bamqc",
        "-nt", "8",
        "-bam", file_path(MAPPING_BWA_DIR) / f1.replace("_1.fastq.gz", "_sorted.bam"),
        "-outdir", file_path(MAPPING_QC_DIR) / f1.replace("_1.fastq.gz", ""),
        "-outformat", "PDF:HTML",
        "-outfile", f1.replace("_1.fastq.gz", ".pdf")])


def qualimap_multi_bamqc() -> None:
    if not file_path(INPUT_GROUPS_FILE):
        raise SystemExit("Error: input_groups_file not configured.")
    if not file_path(INPUT_GROUPS_FILE).is_file():
        raise SystemExit(f"Error: Required input groups file {file_path(INPUT_GROUPS_FILE)} does not exist.")
    qualimap_data_file_path = file_path(MAPPING_QC_DIR) / "input_groups.txt"
    if not qualimap_data_file_path.is_file() or not file_path(INPUT_GROUPS_FILE).samefile(qualimap_data_file_path):
        shutil.copy(file_path(INPUT_GROUPS_FILE), qualimap_data_file_path)
    run([
        "qualimap", "multi-bamqc",
        "-d", qualimap_data_file_path,
        "-outdir", file_path(MAPPING_QC_DIR) / "multibamqc",
        "-outformat", "PDF",
        "-outfile", "Overview-Report.pdf"])


def main() -> None:
    # Measure the elapsed time in nanoseconds - Start
    time_start = perf_counter_ns()

    ###########################################################################
    # -- Step 1 - Index the FASTA reference file
    ###########################################################################

    if process_step(BWA_MEM2_INDEX_REFERENCE_FASTA):
        bwa_mem2_index_reference_fasta()

    ###########################################################################
    # -- Step 2 - Check and prepare all required output directories:
    ###########################################################################
    # -- Create output directories if necessary and configured.
    # -- Clear output directories if configured.
    ###########################################################################

    check_and_prepare_output_dirs()

    ###########################################################################
    # -- Step 3 - Processing chain of the raw FASTQ input files:
    ###########################################################################
    # -- Create fastqc quality reports of the raw FASTQ input files
    # -- -> fastqc
    # -- ----------------------------------------------------------------------
    # -- Repair the raw FASTQ input files
    # -- -> repair.sh
    # -- ----------------------------------------------------------------------
    # -- Perform quality trimming of the raw/repaired FASTQ reads
    # -- -> fastp
    # -- ----------------------------------------------------------------------
    # -- Map the trimmed FASTQ files to the reference FASTA file
    # -- -> bwa-mem2 mem
    # -- ----------------------------------------------------------------------
    # -- Convert the SAM file into BAM format
    # -- -> samtools view
    # -- ----------------------------------------------------------------------
    # -- Sort the BAM file
    # -- -> samtools sort
    # -- ----------------------------------------------------------------------
    # -- Index the sorted BAM file
    # -- -> samtools index
    # -- ----------------------------------------------------------------------
    # -- Delete the unsorted BAM and SAM files
    # -- ----------------------------------------------------------------------
    # -- Create a mapping quality report
    # -- -> qualimap bamqc
    ###########################################################################

    for fastq_file_name_1, fastq_file_name_2 in get_fastq_file_names():
        # Create fastqc quality reports of the raw FASTQ input files
        if process_step(FASTQC):
            fastqc(fastq_file_name_1, fastq_file_name_2)
        # Repair the raw FASTQ input files
        if process_step(REPAIR_FASTQ):
            repair_fastq(fastq_file_name_1, fastq_file_name_2)
        # Perform quality trimming of the raw/repaired FASTQ reads
        if process_step(FASTP):
            fastp(fastq_file_name_1, fastq_file_name_2)
        # Map the trimmed FASTQ files to the reference FASTA file
        # Convert the SAM file into BAM format
        # Sort the BAM file
        # Index the sorted BAM file
        # Delete the unsorted BAM and SAM files
        if process_step(MAPPING_BWA):
            map_bwa(fastq_file_name_1, fastq_file_name_2)
        # Create a mapping quality report
        if process_step(QUALIMAP_BAMQC):
            qualimap_bamqc(fastq_file_name_1)

    ###########################################################################
    # -- Step 4 - Create an overview mapping quality report for all processed
    # --          FASTQ files
    ###########################################################################

    if process_step(QUALIMAP_MULTI_BAMQC):
        qualimap_multi_bamqc()

    ###########################################################################
    # -- Elapsed time in nanoseconds
    ###########################################################################

    time_end = perf_counter_ns()
    time_elapsed_ms = (time_end - time_start) / 1_000_000
    print(f"Execution time in ms: {time_elapsed_ms}.")


if __name__ == "__main__":
    main()
